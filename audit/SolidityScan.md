SolidityScan Report
ArtGalleryToken.sol

File: Hwk_5/src/ArtGalleryToken.sol
Issues
| #  | Name                                  | Severity       | Confidence | Description                                                           | Remediation        |
|----|---------------------------------------|----------------|------------|-----------------------------------------------------------------------|--------------------|
| 1  | Incorrect Access Control           | Critical       | 1          | Access control plays an important role in the segregation of privileges in smart contracts and other applications. If this is misconfigured or not properly validated on sensitive functions, it may lead to loss of funds, tokens and in some cases compromise of the smart contract. The contract is importing an access control library but the function is missing the modifier. | Not Available   |
| 2  | Outdated Compiler Version          | Low            | 2          | Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.                                                                                     | Not Available   |
| 3  | Use Ownable2Step                   | Low            | 0          | Ownable2Step is safer than Ownable for smart contracts because the owner cannot accidentally transfer the ownership to a mistyped address. Rather than directly transferring to the new owner, the transfer only completes when the new owner accepts ownership. | Not Available   |
| 4  | Use of Floating Pragma             | Low            | 2          | Solidity source files indicate the versions of the compiler they can be compiled with using a pragma directive at the top of the solidity file. This can either be a floating pragma or a specific compiler version. The contract was found to be using a floating pragma which is not considered safe as it can be compiled with all the versions described. | Not Available   |
| 5  | Missing Events                     | Low            | 1          | Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction’s log — a special data structure in the blockchain. These logs are associated with the address of the contract which can then be used by developers and auditors to keep track of the transactions. The contract was found to be missing these events on the function which would make it difficult or impossible to track these transactions off-chain. | Not Available   |
| 6  | In-line Assembly Detected          | Informational  | 2          | Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. This should only be used for tasks that need it and if there is confidence in using it. Multiple vulnerabilities have been detected previously when the assembly is not properly used within the Solidity code; therefore, caution should be exercised while using them. | Not Available   |
| 7  | Missing Underscore in Var Names    | Informational  | 0          | Solidity style guide suggests using underscores as the prefix for non-external functions and state variables (private or internal) but the contract was not found to be following the same.                                                   | Not Available   |
| 8  | Name Mapping Parameters            | Informational  | 0          | After Solidity 0.8.18, a feature was introduced to name mapping parameters. This helps in defining a purpose for each mapping and makes the code more descriptive.                                                                             | Not Available   |
| 9  | Revert Statements and DoS          | Informational  | 0          | In public and external functions, improper use of revert can be exploited for Denial of Service (DoS) attacks. An attacker can intentionally trigger these 'revert' conditions, causing legitimate transactions to consistently fail. For example, if a function relies on specific conditions from user input or contract state, an attacker could manipulate these to continually force reverts, blocking the function's execution. | Not Available   |
| 10 | Define Constructor as Payable      | Gas            | 0          | Developers can save around 10 opcodes and some gas if the constructors are defined as payable. However, it should be noted that it comes with risks because payable constructors can accept ETH during deployment. Lines: ["24:31"] | It is suggested to mark the constructors as payable to save some gas. Make sure it does not lead to any adverse effects in case an upgrade pattern is involved. |
| 11 | Reverting Functions Can Be Payable | Gas            | 0          | If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. In the above code, the onlyOwner modifier ensures that only the contract owner can execute the ${function_name}. If a normal user attempts to call this function, the transaction will automatically revert. By marking the ${function_name} as payable, we can optimize gas costs for legitimate callers since the compiler will skip the checks for payment. Lines: ["34:38"] | In the above code, the onlyOwner modifier ensures that only the contract owner can execute the ${function_name}. If a normal user attempts to call this function, the transaction will automatically revert. By marking the ${function_name} as payable, we can optimize gas costs for legitimate callers since the compiler will skip the checks for payment. |
| 12 | Optimizing Address ID Mapping      | Gas            | 0          | Combining multiple address/ID mappings into a single mapping using a struct enhances storage efficiency, simplifies code, and reduces gas costs, resulting in a more streamlined and cost-effective smart contract design. It saves storage slot for the mapping and depending on the circumstances and sizes of types, it can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they fit in the same storage slot. Lines: ["9:9","10:10"] | It is suggested to modify the code so that multiple mappings using the address->id parameter are combined into a struct. |
| 13 | Internal Functions Never Used      | Gas            | 0          | The contract declared internal functions but was not using them in any of the functions or contracts. Since internal functions can only be called from inside the contracts, it makes no sense to have them if they are not used. This uses up gas and causes issues for auditors when understanding the contract logic. Having dead code in the contracts uses up unnecessary gas and increases the complexity of the overall smart contract. It is recommended to remove the internal functions from the contracts if they are never used. Lines: ["74:83"] | Having dead code in the contracts uses up unnecessary gas and increases the complexity of the overall smart contract. It is recommended to remove the internal functions from the contracts if they are never used. |

Scan Summary:

    Lines Analyzed: 79

    Scan Score: 55.70

    Issue Distribution: { "critical": 2, "gas": 5, "high": 0, "informational": 10, "low": 5, "medium": 0 }

Gallery.sol

File: Hwk_5/src/Gallery.sol
Issues
| #  | Name                                  | Severity       | Confidence | Description                                                           | Remediation        |
|----|---------------------------------------|----------------|------------|-----------------------------------------------------------------------|--------------------|
| 1  | INCORRECT ACCESS CONTROL                                   | critical    | 1          | Access control plays an important role in the segregation of privileges in smart contracts and other applications. If this is misconfigured or not properly validated on sensitive functions, it may lead to loss of funds, tokens and in some cases compromise of the smart contract. The contract is importing an access control library but the function is missing the modifier.        | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 2  | BLOCK.NUMBER INCONSISTENCIES ON VARIOUS L2S                | medium      | 0          | On Optimism, block.number represents the L2 block number, whereas on Arbitrum, it reflects the L1 block number, necessitating the use of ArbSys(address(100)).arbBlockNumber() on Arbitrum. Caution is advised as L2 block numbers may occur more frequently than L1 block numbers, leading to timing inconsistencies, especially in voting scenarios across multiple chains. Notably, OZ has addressed this concern in version 4.9 by modifying their governor code to use a clock instead of block numbers. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 3  | ACCOUNT EXISTENCE CHECK FOR LOW LEVEL CALLS               | medium      | 0          | The low-level calls such as the delegatecall, call, or callcode, do not validate prior to the call if the destination account exists or not. They will always return true even if the account is non-existent, therefore, giving invalid output.                                                                                                                                                                              | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 4  | WEAK PRNG                                                  | low         | 0          | Random numbers find their use in many features and function logics. The sole purpose of these random number generators is that it should not be possible to guess or enumerate them. The contract was using functions like block.timestamp, now or blockhash which can be manipulated by miners to some extent, and therefore the integrity of the contract is compromised. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 5  | EVENT BASED REENTRANCY                                     | low         | 1          | In a Re-entrancy attack, a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways, especially in cases where the function is updating state variables after the external calls. In the case of event-based Re-entrancy attacks, events are emitted after an external call leading to missing event calls. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 6  | OUTDATED COMPILER VERSION                                  | low         | 2          | Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.                                                                                                                                                                                                                   | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 7  | MISSING EVENTS                                             | low         | 1          | Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction’s log — a special data structure in the blockchain. These logs are associated with the address of the contract which can then be used by developers and auditors to keep track of the transactions. The contract was found to be missing these events on the function which would make it difficult or impossible to track these transactions off-chain. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 8  | USE OF FLOATING PRAGMA                                     | low         | 2          | Solidity source files indicate the versions of the compiler they can be compiled with using a pragma directive at the top of the solidity file. This can either be a floating pragma or a specific compiler version. The contract was found to be using a floating pragma which is not considered safe as it can be compiled with all the versions described.                                                   | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 9  | MISSING ZERO ADDRESS VALIDATION                            | low         | 2          | The contract is found to lack proper validation for zero address inputs in critical functions, particularly where an 'address' input is expected, like during initialization or setting ownership. Failure to validate zero addresses can result in unwanted contract states, such as having critical roles or operations reference the zero address (0x0), which is universally considered an invalid and non-operational address within Ethereum, potentially leading to the loss of assets or control over the contract's functionality. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 10 | RETURN INSIDE LOOP                                         | informational| 2          | The function has defined a return keyword inside a loop. This represents an error because the loop will simply return on it’s first iteration.                                                                                                                                                                                                                             | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 11 | BLOCK VALUES AS A PROXY FOR TIME                           | informational| 1          | Contracts often need access to time values to perform certain types of functionality. Values such as block.timestamp and block.number can be used to determine the current time or the time delta. However, they are not recommended for most use cases. For block.number, as Ethereum block times are generally around 14 seconds, the delta between blocks can be predicted. The block times, on the other hand, do not remain constant and are subject to change for a number of reasons, e.g., fork reorganizations and the difficulty bomb. Due to variable block times, block.number should not be relied on for precise calculations of time. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 12 | IN-LINE ASSEMBLY DETECTED                                  | informational| 2          | Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. This should only be used for tasks that need it and if there is confidence in using it. Multiple vulnerabilities have been detected previously when the assembly is not properly used within the Solidity code; therefore, caution should be exercised while using them. | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 13 | MISSING UNDERSCORE IN NAMING VARIABLES                     | informational| 0          | Solidity style guide suggests using underscores as the prefix for non-external functions and state variables (private or internal) but the contract was not found to be following the same.                                                                                                                                                                                | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 14 | IF-STATEMENT REFACTORING                                   | informational| 0          | In Solidity, we aim to write clear, efficient code that is both easy to understand and maintain. If statements can be converted to ternary operators. While using ternary operators instead of if/else statements can sometimes lead to more concise code, it's crucial to understand the trade-offs involved.                                                                             | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 15 | NAME MAPPING PARAMETERS                                    | informational| 0          | After Solidity 0.8.18, a feature was introduced to name mapping parameters. This helps in defining a purpose for each mapping and makes the code more descriptive.                                                                                                                                                                                                                                                       | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 16 | ABI.ENCODEPACKED MAY CAUSE COLLISION                       | informational| 2          | The contract is found to be using abi.encodePacked(), which may lead to hash collisions when handling multiple variable-length arguments. Hash collisions occur because abi.encodePacked() concatenates all elements in order without distinguishing between different data types or their lengths. This issue is particularly concerning when the concatenated data is controlled or influenced by external users, but it can also arise internally due to repetitive patterns or complex data structures.                                                                                                                                                                                             | Not Available                                                                                                                                                                                                                                                                                                                                                                        |
| 17 | STORAGE VARIABLE CACHING IN MEMORY                         | gas         | 0          | The contract is using the state variable multiple times in the function. SLOADs are expensive (100 gas after the 1st one) compared to MLOAD/MSTORE (3 gas each).                                                                                                                                                                                              | It is recommended to cache storage variables in memory the first time and then use the cache to avoid multiple SLOADs.                                                                                                                                                                                                                                                                 |
| 18 | CHEAPER CONDITIONAL OPERATORS                              | gas         | 0          | During compilation, x != 0 is cheaper than x > 0 for unsigned integers in solidity inside conditional statements.                                                                                                                                                                                          | Consider using x != 0 in place of x > 0 in uint wherever possible.                                                                                                                                                                                                                                                                                                                     |
| 19 | PUBLIC CONSTANTS CAN BE PRIVATE                            | gas         | 2          | Public constant variables cost more gas because the EVM automatically creates getter functions for them and adds entries to the method ID table. The values can be read from the source code instead.                                                                                                                                                                  | If reading the values for the constants is not necessary, consider changing the public visibility to private.                                                                                                                                                                                                                                                                              |
| 20 | DEFINE CONSTRUCTOR AS PAYABLE                              | gas         | 0          | Developers can save around 10 opcodes and some gas if the constructors are defined as payable. However, it should be noted that it comes with risks because payable constructors can accept ETH during deployment.                                                                                                                                                                                                                                           | It is suggested to mark the constructors as payable to save some gas. Make sure it does not lead to any adverse effects in case an upgrade pattern is involved.                                                                                                                                                                                                                                                                 |
| 21 | OPTIMIZING ADDRESS ID MAPPING                              | gas         | 0          | Combining multiple address/ID mappings into a single mapping using a struct enhances storage efficiency, simplifies code, and reduces gas costs, resulting in a more streamlined and cost-effective smart contract design. It saves storage slot for the mapping and depending on the circumstances and sizes of types, it can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they fit in the same storage slot. | It is suggested to modify the code so that multiple mappings using the address->id parameter are combined into a struct.                                                                                                                                                                                                |
| 22 | NAMED RETURN OF LOCAL VARIABLE SAVES GAS AS COMPARED TO RETURN STATEMENT | gas         | 0          | The function having a return type is found to be declaring a local variable for returning, which causes extra gas consumption. This inefficiency arises because creating and manipulating local variables requires additional computational steps and memory allocation.                                                                                             | It is advisable to use a named returns statement in the function itself to save gas. Named returns optimize gas usage by directly returning variables declared at the function's signature, eliminating the need for additional memory allocation and manipulation of local variables.  |
| 23 | CHEAPER INEQUALITIES IN IF()                               | gas         | 1          | The contract was found to be doing comparisons using inequalities inside the if statement. When inside the if statements, non-strict inequalities (>=, <=) are usually cheaper than the strict equalities (>, <).                                                                                                                                                                              | It is recommended to go through the code logic, and, if possible, modify the strict inequalities with the non-strict ones to save ~3 gas as long as the logic of the code is not affected.                                                                                                                                                                               |
| 24 | ARRAY LENGTH CACHING                                       | gas         | 2          | During each iteration of the loop, reading the length of the array uses more gas than is necessary. In the most favorable scenario, in which the length is read from a memory variable, storing the array length in the stack can save about 3 gas per iteration. In the least favorable scenario, in which external calls are made during each iteration, the amount of gas wasted can be significant.  | Consider storing the array length of the variable before the loop and use the stored length instead of fetching it in each iteration.                                                                                                                                                                                                                                                                                                          |
| 25 | SIMILAR DATATYPES CAN BE PACKED TOGETHER                    | gas         | 0          | The contract is found to be using similar data types within a struct, leading to extra gas usage in Solidity. When a struct incorporates fields with identical data types (such as multiple uint256 variables), failing to pack them efficiently can result in alignment gaps and increased gas consumption due to inefficient storage usage.                                                                                                                                                                                   | It is advisable to implement effective struct packing techniques. By organizing struct fields with similar data types sequentially and ensuring proper alignment, you can minimize storage overhead and optimize gas consumption.                                                                                                                                                                 |
| 26 | CHEAPER INEQUALITIES IN REQUIRE()                          | gas         | 1          | The contract was found to be performing comparisons using inequalities inside the require statement. When inside the require statements, non-strict inequalities (>=, <=) are usually costlier than strict equalities (>, <).                                                                                                                                                                  | It is recommended to go through the code logic, and, if possible, modify the non-strict inequalities with the strict ones to save ~3 gas as long as the logic of the code is not affected.                                                                                                                                                                                                                                        |
| 27 | SPLITTING REQUIRE STATEMENTS                               | gas         | 1          | Require statements when combined using operators in a single statement usually lead to a larger deployment gas cost but with each runtime calls, the whole thing ends up being cheaper by some gas units.                                                                                                                                                                                                                           | It is recommended to separate the require statements with one statement/validation per line.                                                                                                                                                                                                                                                                                                                                                                       |
| 28 | CUSTOM ERRORS TO SAVE GAS                                  | gas         | 2          | The contract was found to be using revert() statements. Since Solidity v0.8.4, custom errors have been introduced which are a better alternative to the revert. This allows the developers to pass custom errors with dynamic data while reverting the transaction and also making the whole implementation a bit cheaper than using revert.                                                                                                                                                              | It is recommended to replace all the instances of revert() statements with error() to save gas.                                                                                                                                                                                                                                                                                                                                                          |

Scan Summary:

    Lines Analyzed: 200

    Scan Score: 59.00

    Issue Distribution: { "critical": 5, "gas": 20, "high": 0, "informational": 17, "low": 7, "medium": 2 }
